---
layout: page

title: starEhancer笔记

permalink: /blogs/starEhancer/index.html
---



# starEhancer笔记

下面来说说我对此文章的理解

**首先来探究一下作者究竟是做了件什么事情**

论文作者采用了三样东西，风格编码器，映射网络和曲线编码器。流程如下：<br>

将源图片和目标风格图片输入到风格编码器，会生成对应的潜在代码 f_a， f_b，接着将两个潜在代码输入到映射网络，该网络会将其映射成L组风格代码{μ_{a,1}，σ_{a,1}...,μ_{a,L}，σ_{a,L}, ..., μ_{b,L}，σ_{b,L}}，然后将这些不同风格的代码对应的输入的曲线编码器的Dual AdaIN中以及将下采样后的原图输入到曲线编码器的输入中，会输出各个通道曲线的参数，在通过应用曲线参数便可以将原图变成残差图片，然后将原图和残差图相加便可得到目标风格图

知道了大体流程后来详细讲讲过程中的细节：

**风格编码器**<br>

​		![风格编码器](https://knox-ye.github.io/blogs/starEhancers/风格编码器.png)<br>

如图所示，风格编码器通过监督学习的方式来学习各个图片的风格类型。需要注意的是NormLayer的输出是风格的嵌入f。嵌入f在通过平均值和单位化后便是我们需要的潜在代码。也就是说在后续的实用当中是用不到图中的FC的。

**曲线编码器**<br>

​		我认为这是这篇文章所创新的点，这篇论文将基于曲线的颜色转换函数和3DLUT相结合，它引入了像素坐标（经过映射）以及多通道之间的关系来计算输出的图像。下图中的j就是第j号通道的意思。公式中I(x,y)没有下标j也就表明是全通道，这里就已经展示了多通道之间的关系了。<br>![变换公式](https://knox-ye.github.io/blogs/starEhancers/变换公式.png)<br>

下面曲线编码器的框架：<br>

![曲线编码器框架](https://knox-ye.github.io/blogs/starEhancers/曲线编码器框架.png)<br>

如上图所示将图片下采样后输入到曲线编码器（减少计算，让其和输入的图片大小无关），然后曲线编码器输出各个曲线的参数u（实际上就是曲线上的点的值）。然后使用这些参数生成出残差图，最后将原图和残差图相加便可得到增强后的图片。

![残差图像](https://knox-ye.github.io/blogs/starEhancers/残差图像.png)

为了让残差图R能够和原图的size对应，需要采取插值法来增加u的信息。上图中的S函数就是一个插值函数。后面的取整的实际上是这个输出向量里面我需要选择的值的索引。于是就可以通过上述公式来计算出残差图像R了（将各个通道之间的映射都融合在一起）。然后将I和R相加便可得到目标图。

**风格编码器和曲线编码器是如何联合在一起的**

![联合](https://knox-ye.github.io/blogs/starEhancers/联合.png)

按照最开始说的风格编码器将潜在代码输入到映射网络后便会被映射成L组风格均值和标准差，然后在曲线编码其中会将特征图和这些标准差进行AdaIN的操作，以此来去除原图风格，并添加目标图的风格。从数学上来说就是让F从a分布转换的b分布的过程。如下图所示，Fj代表特征图的j通道。

![AdaIN](https://knox-ye.github.io/blogs/starEhancers/AdaIN.png)





