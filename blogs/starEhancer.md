---
layout: page

title: starEhancer笔记

permalink: /blogs/starEhancer/index.html
---



# starEhancer笔记

下面来说说我对此文章的理解

**首先来探究一下作者究竟是做了件什么事情**

论文作者采用了三样东西，风格编码器，映射网络和曲线编码器。流程如下：<br>

将源图片和目标风格图片输入到风格编码器，会生成对应的潜在代码 f_a， f_b，接着将两个潜在代码输入到映射网络，该网络会将其映射成L组风格代码{μ_{a,1}，σ_{a,1}...,μ_{a,L}，σ_{a,L}, ..., μ_{b,L}，σ_{b,L}}，然后将这些不同风格的代码对应的输入的曲线编码器的Dual AdaIN中以及将下采样后的原图输入到曲线编码器的输入中，会输出各个通道曲线的参数，在通过应用曲线参数便可以将原图变成残差图片，然后将原图和残差图相加便可得到目标风格图

知道了大体流程后来详细讲讲过程中的细节：

**风格编码器**<br>

​		![风格编码器](https://knox-ye.github.io/blogs/starEhancers/风格编码器.png)<br>

如图所示，风格编码器通过监督学习的方式来学习各个图片的风格类型。需要注意的是NormLayer的输出是风格的嵌入f。嵌入f在通过平均值和单位化后便是我们需要的潜在代码。

**曲线编码器**<br>

​		我认为这是这篇文章所创新的重点，这篇论文将基于曲线的颜色转换函数和3DLUT相结合，它引入了像素坐标（经过映射）以及多通道之间的关系来计算输出的图像。下图中的j就是一个通道的意思。<br>![变换公式](https://knox-ye.github.io/blogs/starEhancers/变换公式.png)<br>

下面曲线编码器的框架：<br>

![曲线编码器框架](https://knox-ye.github.io/blogs/starEhancers/曲线编码器框架.png)<br>

如上图所示将图片降采样后输入到曲线编码器，然后曲线编码器输出各个曲线的参数u（实际上就是曲线上的点的值）。原图使用这些参数生成出残差图，最后将原图和残差图相加便可得到增强后的图片。

![残差图像](https://knox-ye.github.io/blogs/starEhancers/残差图像.png)

为了能够和原图的size对应，需要采取插值法来增加信息。上图中的S函数就是一个插值函数。后面的取整的实际上是我这个输出向量里面我需要选择的值的索引。于是就可以通过上述公式来计算出残差图像R了。然后将I和R相加便可得到目标图。

**风格编码器和曲线编码器是如何联合在一起的**

![联合](https://knox-ye.github.io/blogs/starEhancers/联合.png)

按照最开始说的风格编码器将潜在代码输入到映射网络后便会被映射成L组风格均值和标准差，然后再曲线编码其中会将特征图和这些标准差进行AdaIN的操作，来去除原图风格，并添加目标图的风格。如下图所示，Fj代表特征图的j通道。

![AdaIN](https://knox-ye.github.io/blogs/starEhancers/AdaIN.png)





